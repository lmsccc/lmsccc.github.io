<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[kmp算法]]></title>
    <url>%2F2019%2F07%2F11%2Fkmp%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[KMP算法kmp算法就是在匹配子串中找到相同的前缀和后缀，例如a b c d a b d在字符d的前面的子串中，前面有一个ab，后面也有一个ab，那么当主串与子串匹配到d的时候，如果不匹配，BF算法是从主串的下一个字符重新开始匹配子串，但是KMP算法是这样的，因为d前面的字符串都是匹配的，而子串中又有相同的前缀和后缀，那么就可以说明，与后缀匹配的主串与前缀也是匹配的，所以当下一次匹配的时候，我们可以从前缀的后一个字符开始匹配如下图所以在一开始的时候，我们要对子串构建一个临时数组，这个数组存放的是从这一位字符开始，最长的相同的前缀后缀的长度，就拿上面的abcdabd来举例子a | b | c | d | a | b | d—|—|—|—|—|—|—0|0|0|0|1|2|0然后，当每次匹配失败的时候，就查找匹配失败字符的前一位字符对应的数组上的数字，也就是找到当前匹配失败的字符前面的字符串的最长匹配的前缀和后缀，下一次主串与子串匹配的时候，根据上面找到的这个数字，从子串中对应的索引来进行匹配，例如主串：A B C D A B X A B C D A B D子串：A B C D A B D当匹配到x的时候，子串对应的D不匹配，这时候查找D前面字符的数字，是2，也就是前缀ab和后缀ab，他们的长度就是2，所以，下一次查找的时候，从数组索引为2的字符开始匹配，也就是c，下一次匹配主串 A B C D A B X A B C D A B D子串 A B C D A B DX与C不匹配，查找C前一位对应的数字，是0，说明没有匹配的前缀后缀那么下一次就从子串的头开始匹配主串A B C D A B X A B C D A B D子串 A B C D A B D匹配成功！ 我讲的可能有一些难懂，具体可以上B站：av3246487,这个人讲的比较具体，每一个步骤都详细讲了 达成成就：B站学习 附上我学习了KMP之后解题的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * @param &#123;string&#125; haystack * @param &#123;string&#125; needle * @return &#123;number&#125; */var strStr = function(haystack, needle) &#123; if(needle === "")return 0; var index = 0; var tempArray = [0]; //求临时数组 for(var index2 = 1; index2 &lt; needle.length;)&#123; if(needle[index] === needle[index2])&#123; tempArray[index2] = index + 1; index2++; index++; &#125;else&#123; if(index != 0)&#123; index = tempArray[index - 1]; &#125;else&#123; tempArray[index2] = 0; index2++; &#125; &#125; &#125; //利用KMP算法解 var i = 0; var j = 0; while(i &lt; haystack.length &amp;&amp; j &lt; needle.length)&#123; if(haystack[i] === needle[j])&#123; i++; j++; &#125;else&#123; if(j != 0)&#123; j = tempArray[j - 1]; &#125;else&#123; i++; &#125; &#125; &#125; if(j === needle.length)&#123; return i-j; &#125; return -1;&#125;;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>KMP</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue指令]]></title>
    <url>%2F2019%2F07%2F01%2FVue%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[v-html可以输出HTML而不是纯文本 v-pre有这个属性的标签里面的内容是不会替换的，例如 1&lt;span v-pre&gt;&#123;&#123;这里面的内容是不会被替换的&#125;&#125;&lt;span&gt; v-if123456789&lt;span v-if="show"&gt;&lt;/span&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; show: true &#125; &#125;)&lt;/script&gt; 对应的还有v-else-if和v-else指令，要注意的是，这两个指令要像编程的时候一样紧跟v-if。 VUE在重新渲染的时候，会尽可能的复用已有的元素，而非重新渲染，如果不希望VUE复用元素的话，可以给元素添加key属性，key的值必须是要唯一的。 v-showv-show与v-if是差不多的，但是v-if是重新渲染，v-show是改变元素的display属性，当v-show为false的时候，display会变成none，要注意的是，v-show不可以在template上使用 v-bind这个指令主要是拿来更新属性的，例如123456789&lt;a v-bind:href="url"&gt;&lt;/a&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; url: "http://www.baidu.com" &#125; &#125;)&lt;/script&gt; 这个指令可以用“:”来简写，也就是上面的代码可以这样写 1&lt;a :href="url"&gt;&lt;/a&gt; 当v-bind需要绑定多个class的时候，我们可以这样写 1234567891011121314&lt;div id='app'&gt; &lt;div :class="&#123;'active': isActive, 'error': isError&#125;"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; isActive: true, error: false &#125; &#125;)&lt;/script&gt;//div就会变成这样&lt;div class="active"&gt; 当然，我们也可以通过methods或者计算属性来返回,也可以在data里面设置一个对象,然后对象里面有对应的属性 1234567891011121314151617181920&lt;div id='app'&gt; &lt;div :class="classes"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; isActive: true, error: false &#125;, computed: &#123; classes: function()&#123; return&#123; active: this.isActivity, error: this.false &#125; &#125; &#125; &#125;)&lt;/script&gt; 数组语法我们可以给绑定的属性一个数组 1&lt;div :class="[activeCls, errorCls]"&gt; 数组里面的元素可以用三元表达式，也可以是一个对象，当然也可以用data，computed，methods在动态设置类名的时候，通常都是使用计算属性来设置的。 在组件中使用v-bind当在自定义组件中使用绑定命令的时候，样式只会在这个组件的根元素上被应用，如果需要在子元素上绑定属性，应该使用组件的props来传递。 v-on这个指令主要是用来绑定事件的，在处理函数内部的this指向的是vue实例，例如1234567891011121314151617&lt;div id="app"&gt; &lt;span v-if="show"&gt;你好你好你好&lt;/span&gt; &lt;button v-on:click="click"&gt;隐藏&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; show: true &#125;, methods: &#123; click: function()&#123; this.show = false; &#125; &#125; &#125;) &lt;/script&gt; 这个指令可以用“@”来简写，也就是 1&lt;button @click="click"&gt;隐藏&lt;/button&gt; ＠click 调用的方法名后 可以不跟括号“（）” 。此时，如果该方法有参数，默认会将原生事件对象 event 传入 如果需要传入event对象的话，VUE提供了一个特殊变量$event，可以将其传入。event后面可以跟一些修饰符 修饰符 作用 .stop 阻止单击事件冒泡 .prevent 提交事件不再重载页面 .capture 事件捕获模式 .self 只有事件在该元素本身触发时回调 .once 只触发一次 修饰符可以串联调用 在监听键盘事件的时候，可以使用按键修饰符 12&lt;!-- 只有在keycode是13的时候才调用vm.submit() --&gt;&lt;input @keyup.13="submit"&gt; 还可以之际配置具体按键Vue.config.keyCodes.f1 = 112; 按键修饰符也可以连用 v-cloak这个指令会在VUE实例结束编译的时候从绑定的HTML元素上移除，这是用来清除“抖动”的，什么是“抖动”呢，在我们使用{{ }}的时候，如果网速较慢，在vue.js文件还未加载出来的时候，这个HTML结构是不会被替换掉的，那么，我们就需要为使用了{{ }}的元素加上一个v-cloak属性，然后设置CSS 123[v-cloak]&#123; display: none;&#125; v-once这个指令代表其元素或着组件只会渲染一次，无论其依赖的数据有没有改变。但是在实际中很少用到，一般用于优化性能 v-for当需要遍历一个对象显示的时候，会用到这个指令，这个指令要结合in来使用 1234567891011121314151617&lt;div id="app"&gt; &lt;ul&gt; &lt;li v-for="book in books"&gt; &#123;&#123; book.name &#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; .... data:&#123; books: [ &#123; name: '123'&#125;, &#123; name: '456'&#125;, &#123; name: '789'&#125; ] &#125; .... v-for还支持一个可选参数作为当前项的索引 1&lt;li v-for="(book, index) in books"&gt; &#123;&#123;index&#125;&#125; - &#123;&#123;book.name &#125;)&lt;/li&gt; 在遍历对象的时候还有参数就会变成这样 1v-for="(value, key, index) in user" v-for也还可以以computed计算的返回值为遍历对象 v-for可以用在template中 数组更新当修改数组的时候，VUE也是会重新渲染视图的，但是当使用filter，concat，slice这些不会改变原数组的方法的时候，是不会重新渲染的。当通过索引直接改变数组项或者通过修改数组长度的时候，VUE是不会重新渲染的。 解决通过索引修改数组而不会重新渲染的问题可以使用VUE内置的SET方法 12Vue.set(app.books, 3, &#123; name: '《css揭秘》' ,author: '[希] Lea Verou ’&#125;); 另外一种方法是通过splice来解决 1234567app.books.splice(3, 1, &#123; name: '123', author: '456'&#125;)//第二个问题也是用splice来解决app.books.splice(1)//第二个参数不写就是删除掉后面全部的 v-modelv-model用于在表单元素上双向绑定数据 单选按钮在只有一个单选按钮的时候，可以直接使用v-bind来绑定checked属性 1234567&lt;input type="radio" :checked="picked"&gt;....data: &#123; picked: true&#125;.... 当有多个单选框并且互斥的时候，要配合v-model和value来使用，将v-model绑定到一个变量中，然后这个变量存的是不同单选框的value，当这个变量与单选框的value相同的时候，这单选按钮就被选中了。 复选框当只有一个复选框的时候，直接使用v-model来绑定一个布尔变量，true选中，false不选中，当有多个复选框的时候，与单选一样，也要v-model配合value来使用。但是变量就变成了一个数组，数组中存放的是每个复选框的value，当复选框被选中的时候，这个复选框的value值会自动push到这个数组中。而这个数组中存在与某个复选框的value的值相同的时候，这个复选框也会被选中。 下拉框在select用v-model绑定一个数组，如果数组中的项与option中的项匹配，那么这个option就会被选中，如果option有value，那么会优先匹配value，如果要开启多选，给v-model加多一个multiple属性 修饰符v-model也是有修饰符的 .lazy在输入框中，默认是在input事件中同步输入框的数据，但是如果给v-model加上.lazy修饰符之后，就是在change事件中同步输入框的数据了，也就是说，只有在input失去焦点或者按下回车的时候，v-model对应的数据才会更新。 .number.number可以将输入的数据类型转换为Number，默认的input数据类型是String .trim.trim修饰符可以过滤掉输入的首尾空格]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue学习基础篇]]></title>
    <url>%2F2019%2F07%2F01%2FVue%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[过滤器vue可以在{{ }}插值的尾部添加一个 “|” 来对数据进行过滤123456789101112131415161718192021222324252627282930313233&#123;&#123; date | formatDate&#125;&#125;&lt;script&gt; var padDate = function(value)&#123; return value &lt; 10 ? '0' + value : value; &#125; var app = new Vue(&#123; el: #app, data: new Date(), filters: &#123; formatDate: function(value)&#123; var date = new Date(value); var year = date.getFullYear(); var month = padDate(date.getMonth() + 1); var day = padDate(date.getDate()); var hours = padDate(date.getHours()); var minutes = padDate(date.getMinutes()); var seconds = padDate(date.getSeconds()); return year + '-' + month + "-" + day + "" + hours + ":" + minutes + ":" + seconds; &#125; &#125;, mounted: function()&#123; this.timer = setInterval(function()&#123; this.date = new Date(); &#125;.bind(this),1000); &#125;, destoryed: function()&#123; if(this.timer)&#123; clearInterval(this.timer); &#125; &#125; &#125;)&lt;/script&gt; 过滤器可以串联，也就是可以这样1&#123;&#123; message | filterA | filterB&#125;&#125; 也可以传参1&#123;&#123; message | filter('arg1','arg2')&#125;&#125; 当然了，过滤器接收到的第一个参数是数据本身，第二第三个参数才是我们传入的参数。 计算属性当遇到复杂的操作的时候，我们有时会需要这样做 123&lt;div&gt; &#123;&#123; text.split(",").reverse().join(",") &#125;&#125;&lt;/div&gt; 这样写会变得难以维护，所以我们可以使用计算属性 1234567891011121314&lt;div id="app"&gt;&#123;&#123; reversedText &#125;&#125;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; text: "123,456" &#125; computed: &#123; reversed: function()&#123; return this.text.split(",").reverse().join(","); &#125; &#125; &#125;)&lt;/script&gt; 在计算属性中包含着getter和setter，getter在获取这个属性的时候会触发，setter在设置这个属性的时候会触发，不过我们一般都使用默认的getter和setter，不必更改。计算属性不仅可以依赖当前VUE实例，还可以依赖另外的VUE实例123456789101112131415161718&lt;div id="app1"&gt;&lt;/div&gt;&lt;div id="app2"&gt;&#123;&#123; resveredText &#125;&#125;&lt;/div&gt;&lt;script&gt; var app1 = new Vue(&#123; el: '#app1', data: &#123; name: "123,456" &#125; &#125;) var app2 = new Vue(&#123; el: '#app2', computed: &#123; resveredText: function()&#123; return app1.name.split(","); &#125; &#125; &#125;)&lt;/script&gt; 计算属性缓存其实上面的computed也可以用一个函数来实现，并且用函数实现还可以传递参数，那用函数和用计算属性有什么区别呢？ 属性 页面重新渲染 适用场景 computed 不变化 较大的计算量和较低的更新频率 methods 页面元素的data变化 无缓存 这里的意思是，当使用computed来实现的时候，只有其依赖的数据本身变化了，视图才会去更新，但是如果用methods来实现的话，只要页面有有一个地方被重新渲染了，调用methods的地方都会更新。 组件组件注册全局注册123Vue.component('my-component',&#123; template: "&lt;div&gt;我的第一个component&lt;/div&gt;"&#125;) 局部注册12345678910var myComponent = &#123; template: "&lt;div&gt;我的第一个component&lt;/div&gt;"&#125;var app = new Vue(&#123; el: "#app", component: &#123; "my-component": myComponent &#125;&#125;) 组件嵌套可以在一个组件里面注册另一个组件例如 1234567891011121314151617var child = &#123; template: "&lt;div&gt;子component&lt;/div&gt;"&#125;var myComponent = &#123; template: "&lt;div&gt;我的第一个component&lt;/div&gt;&lt;child&gt;&lt;/child&gt;" component: &#123; "child": child &#125;&#125;var app = new Vue(&#123; el: "#app", component: &#123; "my-component": myComponent &#125;&#125;) is的使用Vue 组件的模板在某些情况下会受到 HTML 的限制，比如＜table＞内规定只允许是〈tr〉、＜td＞、 ＜th＞等这些表格元素，所以在＜table＞内直接使用组件是无效的。 这种情况下，可以使用特殊的 is 属性来挂载组件 123&lt;table&gt; &lt;tbody is="my-component"&gt;&lt;/tbody&gt;&lt;/table&gt; 传递参数12345678910111213&lt;div id='app'&gt; &lt;my-compontent message="haha"&gt;&lt;/my-compontent&gt;&lt;/div&gt;&lt;script&gt; Vue.compontent('my-compontent',&#123; props: ['message'], template: "&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;" &#125;) var app = new Vue(&#123; el: '#app' &#125;)&lt;/script&gt; 如果要动态传递的话，将message用v-bind绑定就可以了 单向数据流从父组件传过来的数据，父组件的数据变化时会传递给子组件，但是反过来不可以。有两种情况需要改变prop的 这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。在这种情况下，最好定义一个本地的 data 属性并将这个 prop 用作其初始值： 123456props: ['initialCounter'],data: function () &#123; return &#123; counter: this.initialCounter &#125;&#125; 这个 prop 以一种原始的值传入且需要进行转换。在这种情况下，最好使用这个 prop 的值来定义一个计算属性： 123456props: ['size'],computed: &#123; normalizedSize: function () &#123; return this.size.trim().toLowerCase() &#125;&#125; 注意在 JavaScript 中对象和数组是通过引用传入的，所以对于一个数组或对象类型的 prop 来说，在子组件中改变这个对象或数组本身将会影响到父组件的状态。 这句话的意思是如果你传入的props是一个对象或者是数组的话，因为对象和数组的传递是引用类型的，当你在子组件改变这个对象或者数组的时候，父组件中对应的数组或者对象也会被改变。 数据验证1234567891011121314151617181920212223242526272829props: &#123; //数字类型 propA: Number, //字符串类型或者数字类型 propB: [String,Number], //布尔类型 propC: &#123; type: Boolean, default: true &#125;, //数字类型并且必须传 propD: &#123; type: Number, required: true &#125;, //如果要求是对象或者数组，默认值要用函数返回 propE: &#123; type: Object, default: function()&#123; return &#123;&#125;; &#125; &#125; //自定义验证函数 propF: &#123; validator: function(value)&#123; return value &gt; 10; &#125; &#125;&#125; type的类型可以是 String Array Number Object Function Boolean当然也可以自定义类型的判断，用instanceof就可以了。 组件通信子组件可以通过$emit触发一个事件，这个事件是被父组件监听的。 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;div id='app'&gt; &lt;my-component //监听事件 @addCount="handleTotal" @reduceCount="handleTotal"&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;script&gt; Vue.component("my-component",&#123; template: '\ &lt;div&gt;\ &lt;button @click="handleAdd"&gt;+1&lt;/button&gt;\ &lt;button @click="handleReduce"&gt;-1&lt;/button&gt;\ &lt;div&gt;', data: function()&#123; return &#123; counter: 0 &#125; &#125;, mehtods: &#123; handleAdd: function()&#123; this.counter++; //触发事件 this.$emit('addCount',this.counter); &#125;, handleReduce: function()&#123; this.counter--; this.emit('reduceCount',this.counter); &#125; &#125; &#125;); var app = new Vue(&#123; el: '#app', data: &#123; counter: 0 &#125;, methods: &#123; handleTotal: function(total)&#123; this.counter = total &#125; &#125; &#125;)&lt;/script&gt; 除了监听自定义事件，还可以监听原生事件，监听该组件的根元素 1&lt;my-component @click.native="handleClick"&gt;&lt;/my-component&gt; 组件上的V-model当在组件上使用v-model的时候，会默认利用名为value的prop和名为input的事件，也就是说，你可以在组件设置里面接收一个叫value的prop，当emit一个input事件的时候组件也会响应去更新v-model对应的数据。可是如单选框，复选框等类型的输入控件会将value特性用于不同的目的，那么组件就要这样设置 12345678910111213141516Vue.component('base-checkbox', &#123; model: &#123; prop: 'checked', event: 'change' &#125;, props: &#123; checked: Boolean &#125;, template: ` &lt;input type="checkbox" v-bind:checked="checked" v-on:change="$emit('change', $event.target.checked)" &gt; `&#125;) 现在在这个组件上使用 v-model 的时候： 1&lt;base-checkbox v-model="lovingVue"&gt;&lt;/base-checkbox&gt; 这里的 lovingVue 的值将会传入这个名为 checked 的 prop。同时当 触发一个 change 事件并附带一个新的值的时候，这个 lovingVue 的属性将会被更新。 利用v-model双向通信父组件向子组件通信-&gt;利用props传递子组件向父组件通信-&gt;通过触发父组件监听的事件 12345678910111213141516171819202122232425262728293031&lt;div id='app'&gt; &lt;my-component v-model='counter'&gt;&lt;/my-component&gt; &lt;button @click='handleAdd'&gt;+1&lt;/button&gt;&lt;div&gt;&lt;script&gt; Vue.component("my-component",&#123; template: '&lt;input type="text" :value="value" @input="handleCounter"&gt;', props=['value'], methods: &#123; handleCounter: function(event)&#123; this.$emit('input',event.target.value); &#125; &#125;, data: function()&#123; return &#123; counter: 0; &#125; &#125; &#125;) var app = new Vue(&#123; el: '#app', methods: &#123; handleAdd: function()&#123; this.counter++ &#125; &#125;, data: &#123; counter: 0; &#125; &#125;)&lt;/script&gt; 利用空VUE实例实现组件间通信123456789101112131415161718192021222324252627282930var bus = new Vue();//组件1Vue.component("com1",&#123; template: '&lt;button @click='changeValue'&gt;+1&lt;/button&gt;', data: function()&#123; return &#123; val: 0 &#125; &#125;, methods: &#123; changeValue: function()&#123; this.val++; bus.$emit('changeValue',this.val); &#125; &#125;&#125;)//组件2Vue.component("com2",&#123; data: function()&#123; return &#123; val :0 &#125; &#125;, mounted: function()&#123; bus.on('changeValue',function(val)&#123; this.val = val; console.log(this.val); &#125;); &#125;&#125;) 父链可以通过this.$parent访问到父组件，还可以通过this.$children访问其子组件，可以递归向上向下一直访问 子组件索引1234567//为组件添加一个ref属性&lt;my-component ref="comA"&gt;&lt;/my-component&gt;... //可以这样子来访问子组件 this.$refs.comA... slotslot的意思是插槽，在组件的模板中使用slot，那么在调用组件的时候，就可以向这些slot插入元素。 单个slot12345678910111213141516171819&lt;div id='app'&gt; &lt;my-component&gt; &lt;p&gt;分发的内容&lt;/p&gt; &lt;p&gt;分发的内容2&lt;/p&gt; &lt;/my-component&gt;&lt;/div&gt;&lt;script&gt; Vue.component("my-component",&#123; template: '\ &lt;div&gt;\ &lt;slot&gt;\ &lt;div&gt;默认内容&lt;/div&gt; &lt;/slot&gt;\ &lt;/div&gt;' &#125;)var app = new Vue(&#123; el: '#app'&#125;)&lt;/script&gt; 渲染出来的结果是 123456&lt;div id='app'&gt; &lt;div&gt; &lt;p&gt;分发的内容&lt;/p&gt; &lt;p&gt;分发的内容2&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 还可以给slot加上名字，就可以指定slot要插入什么内容 1234567891011121314151617181920212223242526272829&lt;div id='app'&gt; &lt;my-component&gt; &lt;h2 slot='header'&gt;题目&lt;h2&gt; &lt;p&gt;分发的内容&lt;/p&gt; &lt;p&gt;分发的内容2&lt;/p&gt; &lt;div slot='footer'&gt;底部信息&lt;/div&gt; &lt;/my-component&gt;&lt;/div&gt;&lt;script&gt; Vue.component("my-component",&#123; template: '\ &lt;div&gt;\ &lt;div class="header"&gt;\ &lt;slot name="header"&gt;&lt;/slot&gt;\ &lt;/div&gt;\ &lt;div class="main"&gt;\ &lt;slot&gt;\ &lt;div&gt;默认内容&lt;/div&gt;\ &lt;/slot&gt;\ &lt;/div&gt;\ &lt;div class="footer"&gt;\ &lt;slot name="footer"&gt;&lt;/slot&gt;\ &lt;/div&gt;\ &lt;/div&gt;' &#125;)var app = new Vue(&#123; el: '#app'&#125;)&lt;/script&gt; 渲染结果 123456789101112&lt;div id='app'&gt; &lt;div class='header'&gt; &lt;h2&gt;题目&lt;/h2&gt; &lt;/div&gt; &lt;div class='main'&gt; &lt;p&gt;分发的内容&lt;/p&gt; &lt;p&gt;分发的内容2&lt;/p&gt; &lt;/div&gt; &lt;div class='footer'&gt; &lt;div&gt;底部信息&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 在模板中，有一个没有名字的slot，所以父组件没有指定slot的内容才可以放在这里，如果模板中没有匿名slot，那么父组件中这些没有指定slot的内容将会被舍去。 作用域slot就是让父组件决定结构，子组件提供数据1234567891011121314151617··· &lt;my-component&gt; &lt;template scope='props'&gt; &lt;p&gt;父组件的内容&lt;/p&gt; &lt;p&gt;&#123;&#123; props.msg &#125;&#125;&lt;/p&gt; &lt;/template&gt; &lt;/my-component&gt;···... Vue.component("my-component",&#123; template: '\ &lt;slot msg="子组件的内容"&gt; &lt;/slot&gt; ' &#125;)... 1234567891011121314151617181920212223242526272829303132&lt;my-component :books='books'&gt;//绑定父组件books &lt;template slot='book' scope='props'&gt; &lt;li&gt;&#123;&#123; props.bookName &#125;&#125;&lt;li&gt; &lt;/template&gt;&lt;/my-component&gt;Vue.component('my-component',&#123; props: &#123; //获取父组件传进来的books books: &#123; type: Array default: function()&#123; return []; &#125; &#125; template:'\ &lt;ul&gt;\ &lt;!--绑定传进来的bookName,父组件通过props.bookName访问到，也就是--&gt; &lt;!--子组件向父组件提供了数据--&gt; &lt;slot name="book" v-for="book in books" :book-Name="book.name"&gt;\ &lt;/ul&gt;\' &#125;&#125;)var app = new Vue(&#123; el: '#app', data: &#123; books:[ &#123;name: 'javascript'&#125;, &#123;name: 'css'&#125;, &#123;name: 'html'&#125; ] &#125;&#125;) 递归组件可以在组件内部调用自己，设置name属性就可以了 1234567···name: 'my-component'template:'\&lt;div&gt;\ &lt;my-component&gt;&lt;/my-component&gt;\&lt;/div&gt;'··· 要注意设置递归跳出条件，否则内存会溢出 内联模板这个功能就是在组件使用的时候加一个inline-template，然后注册组件的时候就不用设置template了，template以组件内的内容为准。 动态组件有一个特殊的元素可以用于动态挂载不同的组件 123456789101112131415161718192021222324252627&lt;component :is="currentView"&gt;&lt;/component&gt;&lt;button @click='handleChange('A')'&gt;切换到A&lt;/button&gt;&lt;button @click='handleChange('B')'&gt;切换到B&lt;/button&gt;&lt;button @click='handleChange('C')'&gt;切换到C&lt;/button&gt;···var app = new Vue(&#123; components: &#123; comA: &#123; template: '&lt;div&gt;组件A&lt;/div&gt;' &#125;, comB: &#123; template: '&lt;div&gt;组件B&lt;/div&gt;' &#125;, comC: &#123; template: '&lt;div&gt;组件C&lt;/div&gt;' &#125; &#125;, data: &#123; currentView: 'comA' &#125;, methods: &#123; handleChange: function(component)&#123; this.currenntView = 'com' + component; &#125; &#125;&#125;) 也可以创建一个对象然后将组件绑定在这个对象上 123456var Home = &#123; template:'&lt;p&gt;Welcome home!&lt;/p&gt;' &#125; ;var app =new Vue(&#123; el:'#app', data: &#123; currentView: Home &#125;) $nextTickvue的更新是异步更新的，例如，Vue在观察到数据变化要更新DOM的时候，VUE会开启一个队列，并缓冲在同一事件循环中发生的所有数据改变，缓冲的时候会去除掉所有重复的数据。在下一个tick中，vue才回去刷新队列执行实际的DOM操作。 1234567891011··· this.showDiv = true; //下面的句子会报错，因为这个时候DIV还没有被创建出来的 var text = document.getElementById('div').innerHTML··· //利用$nextTick在DOM更新完成的时候执行 this.showDiv = true; this.$nextTick(function()&#123; var text = document.getElementById('div').innerHTML &#125;) X-Templates在script标签里面写模板,在script标签里面使用text/x-template类型就可以了 123456789&lt;script type="text/x-template" id="my-component"&gt; &lt;div&gt;利用script写模板&lt;/div&gt;&lt;/script&gt;&lt;script&gt; Vue.component("my-component",&#123; template: 'my-component' &#125;);&lt;/script&gt; 手动挂载实例如果Vue在实例化的时候没哟收到el选项，此时的VUE实例是处于未挂载的状态的，Vue提供了Vue.extend和$mount两种方法来手动挂载实例。 12345678910111213141516171819202122&lt;div id='app'&gt;&lt;script&gt; var myComponent = Vue.extend(&#123; template: "&lt;div&gt;hello: &#123;&#123; name &#125;&#125;&lt;/div&gt;", data: function()&#123; return &#123; name: 'Aresn' &#125; &#125; &#125;); new myComponent().$mount('#app'); //还可以这样挂载 new myComponent(&#123; el: '#app' &#125;) //或者这样，先渲染再挂载 var component = new myConponent().$mount(); document.getElementById('app').appendChild(component.$el);&lt;/script&gt; 自定义指令我个人理解，指令就是让这个组件干什么，而组件就是说这个元素是什么。组件的注册方式和组件大体是相同的指令有几个钩子函数 bind 当指令第一次绑定到元素的时候触发，多用于绑定事件 inserted 当被绑定元素插入到父节点的时候触发，即使父节点不在document中 update 被绑定元素所在的模板更新的时候触发 componentUpdate 被绑定元素所在模板完成一次更新周期的时候调用 unbind 指令和元素解绑的时候调用 其中每个钩子函数又有几个参数可以使用 el 指令绑定的元素 bingding 一个对象，包含以下属性 name 指令的名字 value 指令的绑定值 oldValue 指令绑定的前一个值，限于update和componentUpdated中使用 expression value的字符串形式 arg 传给指令的参数 modifiers 一个包含修饰符的对象 vnode Vue编译生成的虚拟节点 oldValue 上一个虚拟节点，限于update和componentUpdated中使用]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博文]]></title>
    <url>%2F2019%2F05%2F21%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E6%96%87%2F</url>
    <content type="text"><![CDATA[这是我的博客的第一篇文章，就讲讲我是如何搭建我的博客的吧 环境准备Node首先我们要为我们的电脑装上node，直接去官网下载安装好配置好环境变量就可以了 Hexo接着我们要安装node环境下的hexo框架，这个框架可以很方便的为我们快速生成一个博客的模板，并且还有许多主题可以选择 git我们还要在电脑上安装git，这样我们就可以将我们的博客部署到github上 搭建过程1npm install hexo -g 这里我们全局安装一下hexo框架，然后建立一个项目文件夹，这个文件夹是用来装我们的blog项目的首先要打开CMD，用cd命令跳转到我们建立好的blog文件夹，然后用hexo初始化这个文件夹，比如我的 12cd E://bloghexo init 这样子我们这个文件夹就已经是一个可以运行的博客了 123hexo startINFO Start processingINFO Hexo is running at http://localhost:4000 . Press Ctrl+C to stop. 当看到这个语句的时候，我们的博客就已经运行起来了，只需要在浏览器中输入localhost:4000就可以访问到我们的博客了 主题更换如果我们想要更换主题的话，我们可以做以下的更改 首先要获取到主题之前我们已经安装好了git，我们只需要用git clone这个命令就可以将主题文件获取到本地，例如我的 1git clone https://github.com/theme-next/hexo-theme-next.git themes/next 这里要注意的是，我们要将主题文件clone到项目中的themes文件夹中 修改hexo的配置文件打开项目文件夹下的_config.yml，找到theme这个配置项，将其修改成themes文件夹里面对应的文件夹名称就可以了 部署到github建立仓库首先到github中建立一个仓库，仓库名一定要是username.github.io,uesrname是你的github用户名,否则后面访问会出现404 修改配置文件找到_config.yml,修改里面的#Deployment选项， 1234#Deployment type：git repo: //刚刚建立的github仓库的http地址 branch: master 改好之后就保存就可以了 推送然后我们可以使用hexo三连 123hexo cleanhexo g //生成hexo d //推送到服务器 这个时候你就可以访问username.github.io，uesrname是你的github用户名来看到你的个人博客啦。 最后如果你是一个前端开发人员的话，你也可以到主题文件夹中对你的博客进行魔改，这也是我接下来准备做的工作。]]></content>
      <categories>
        <category>教程</category>
      </categories>
  </entry>
</search>
