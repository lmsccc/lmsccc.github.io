<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Neteaseban]]></title>
    <url>%2F2019%2F08%2F21%2FNeteaseban%2F</url>
    <content type="text"><![CDATA[介绍这是我学习完VUE全家桶之后练习的项目，目前只完成了豆瓣部分，网易云准备开始着手，豆瓣部分UI是自己写的，感觉好累。。后面的网易云部分准备用vant来写UI，不自己写了。项目中的图片加载使用了vue的插件vue-lazyload，下拉加载更多图片是自己写的。豆瓣的搜索功能是没有做的，因为豆瓣的搜索API最近关闭了。 用到的知识vue + axios + vue-router + Vuex + vue-cli 运行截图 源码地址https://github.com/lmsccc/neteaseban]]></content>
      <categories>
        <category>练习</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6学习之Proxy]]></title>
    <url>%2F2019%2F08%2F17%2FES6%E5%AD%A6%E4%B9%A0%E4%B9%8BProxy%2F</url>
    <content type="text"><![CDATA[什么是Proxyproxy原意为代理，代理在计算机中通常是指代理服务器，当我们要访问一个网址的时候，要先访问代理服务器，再由代理服务器去访问要访问的网址。而es6中代理的不是服务器，而是对象，当我们要访问一个对象的时候，要先经过Proxy。 如何使用proxyproxy使用构造函数来构建一个新的proxy实例 1var proxy = new Proxy(target,handler); 其中，target是要设置代理的对象，而handler则是一个用于设置拦截行为的对象 如果将proxy设置在对象的原型上也可以 12345678var proxy = new Proxy(&#123;&#125;, &#123; get: function(target, property) &#123; return 35; &#125;&#125;);let obj = Object.create(proxy);obj.time // 35 obj上没有time属性，所以到原型中去搜索，那么就要经过proxy拦截，而get是一直返回35的，所以访问obj.time返回的是35 要注意的是，如果想要proxy生效，要对proxy实例进行操作而不是对目标对象进行操作。 proxy支持的拦截操作 get(target, propKey, receiver)：拦截对象属性的读取，比如proxy.foo和proxy[&#39;foo&#39;]。 set(target, propKey, value, receiver)：拦截对象属性的设置，比如proxy.foo = v或proxy[&#39;foo&#39;] = v，返回一个布尔值。 has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值。 deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值。 ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。 getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。 defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。 preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值。 getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象。 isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值。 setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。 apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)。 construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(...args)。 例子get下面是一段利用get来实现生成各种dom节点的通用函数dom123456789101112131415161718192021222324252627282930313233const dom = new Proxy(&#123;&#125;, &#123; get(target, property) &#123; return function(attrs = &#123;&#125;, ...children) &#123; //通过拦截访问对象的属性来创建dom节点 const el = document.createElement(property); //为DOM添加的属性 for (let prop of Object.keys(attrs)) &#123; el.setAttribute(prop, attrs[prop]); &#125; //处理DOM的子节点 for (let child of children) &#123; if (typeof child === 'string') &#123; child = document.createTextNode(child); &#125; el.appendChild(child); &#125; return el; &#125; &#125;&#125;);const el = dom.div(&#123;&#125;, 'Hello, my name is ', dom.a(&#123;href: '//example.com'&#125;, 'Mark'), '. I like:', dom.ul(&#123;&#125;, dom.li(&#123;&#125;, 'The web'), dom.li(&#123;&#125;, 'Food'), dom.li(&#123;&#125;, '…actually that\'s it') ));document.body.appendChild(el); set利用get来防止内部属性被访问 12345678910111213141516171819202122const handler = &#123; get (target, key) &#123; invariant(key, 'get'); return target[key]; &#125;, set (target, key, value) &#123; invariant(key, 'set'); target[key] = value; return true; &#125;&#125;;function invariant (key, action) &#123; if (key[0] === '_') &#123; throw new Error(`Invalid attempt to $&#123;action&#125; private "$&#123;key&#125;" property`); &#125;&#125;const target = &#123;&#125;;const proxy = new Proxy(target, handler);proxy._prop// Error: Invalid attempt to get private "_prop" propertyproxy._prop = 'c'// Error: Invalid attempt to set private "_prop" property 总结proxy还有很多其他拦截器，我就不去仔细看了，等用到的时候再研究吧，感觉用的最多的会是get和set两个拦截器。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>Proxy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6学习之Symbol]]></title>
    <url>%2F2019%2F08%2F15%2FES6%E5%AD%A6%E4%B9%A0%E4%B9%8BSymbol%2F</url>
    <content type="text"><![CDATA[什么是symbolsymbol是用来防止属性名冲突的，用symbol创建的值是独一无二的 创建symbol12let a = Symbol();typeof a//symbol 在es6中，symbol也成为了JavaScript的数据类型之一，其他六种是，undefind，null，number，string，boolean，object symbol创建的时候也可以传入参数，但是这仅仅是他们的标识符而已，标识符相同这两个symbol并不是相同的123let a = Symbol("abc");let b = Stmbol("abc");a === b //false; 如果需要读取这个标识符，可以使用description12let a = Symbol("abc");a.description() // "abc" Symbol的作用symbol可以用来作为对象属性的唯一标识符，当一个对象是由多个模块组成的时候，就不怕属性会被覆盖了，在用symbol作为属性的标识符的时候，不可以用点运算符，例如 123456let a = Symbol();let b = &#123;&#125;;b.mySymbol = "hello";b[mySymbol] //undefind;b["mySymbol"]//"hello" 这是因为用点运算符添加的属性本质上他的属性名是字符串类型而不是symbol类型的,在对象里面定义属性的时候也要将symbol写在中括号里面 123456let a = Symbol();let b = &#123; [a]: function()&#123; //somecode &#125;&#125; 例子消除魔术字符串123456789101112function getArea(shape, options) &#123; let area = 0; switch (shape) &#123; case 'Triangle': // 魔术字符串 area = .5 * options.width * options.height; break; /* ... more code ... */ &#125; return area;&#125;getArea('Triangle', &#123; width: 100, height: 100 &#125;); // 魔术字符串 这里Triangle是强耦合的，我们要消除它 123456789101112131415const shapeType = &#123; triangle: 'Triangle'&#125;;function getArea(shape, options) &#123; let area = 0; switch (shape) &#123; case shapeType.triangle: area = .5 * options.width * options.height; break; &#125; return area;&#125;getArea(shapeType.triangle, &#123; width: 100, height: 100 &#125;); 我们发现，shapeType.triangle的值是无所谓的，所以，我们可以将shapeType的triangle用symbol来代替 123const shapeType = &#123; triangle: Symbol()&#125;; 单例模式当我们将单例放到全局对象中的时候 12345678910// mod.jsfunction A() &#123; this.foo = 'hello';&#125;if (!global._foo) &#123; global._foo = new A();&#125;module.exports = global._foo; 加载模块12const a = require('./mod.js');console.log(a.foo); //"hello" 这里有一点危险，因为global._foo是可写的 1234global._foo = &#123; foo: 'world' &#125;;const a = require('./mod.js');console.log(a.foo); //"hello" 所以我们可以用在global对象上用symbol作为属性名 1234567891011const FOO_KEY = Symbol.for('foo');function A() &#123; this.foo = 'hello';&#125;if (!global[FOO_KEY]) &#123; global[FOO_KEY] = new A();&#125;module.exports = global[FOO_KEY]; 这样，在global对象上就有一个独一无二的对象名，不怕无意和别人的属性名冲突了，要注意，是无意！但其实如果用Symbol.for来写的话还是可以被改写的。 123global[Symbol.for('foo')] = &#123; foo: 'world' &#125;;const a = require('./mod.js'); 如果想要不被改写的话，只能使用Symbol（）来生成symbol了 定义一组值不会重复的常量12345678910111213const COLOR_RED = Symbol();const COLOR_GREEN = Symbol();function getComplement(color) &#123; switch (color) &#123; case COLOR_RED: return COLOR_GREEN; case COLOR_GREEN: return COLOR_RED; default: throw new Error('Undefined color'); &#125;&#125; 总结最后，symbol是不可枚举的，也就是说，for..of for..in Object.keys()是不能遍历到symbol类型的值的，要得到symbol的值有两种办法，一种是使用Object.getOwnPropertySymbols,返回一个数组包括这个对象中所有的symbol类型的值，另一种是使用Reflect.ownKeys,可以返回常规类型的键名和symbol类型的。我个人认为，symbol就是可以生成一个永不重复的值，然后怎么使用这个值就看写程序的人了。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>Symbol</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是bfc？]]></title>
    <url>%2F2019%2F08%2F12%2Fbfc%2F</url>
    <content type="text"><![CDATA[当初一开始学习CSS的时候就听说过BFC，跟浮动相关的，一直说什么触发BFC清除浮动，但是那时候我也没有具体去了解过BFC是什么东西，甚至不知道如何触发BFC，BFC的作用，只是照着别人清除浮动的方式来做。今天刚好又遇到了BFC，那么就来了解一下BFC到底是什么东西 什么是BFC以下是MDN官方的定义 块格式化上下文（Block Formatting Context，BFC） 是Web页面的可视化CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。块格式化上下文包含创建它的元素内部的所有内容. 块格式化上下文对浮动定位（参见 float）与清除浮动（参见 clear）都很重要。浮动定位和清除浮动时只会应用于同一个BFC内的元素。浮动不会影响其它BFC中元素的布局，而清除浮动只能清除同一BFC中在它前面的元素的浮动。外边距折叠（Margin collapsing）也只会发生在属于同一BFC的块级元素之间。 这个解释根本看不懂啊，后来我去找了一下BFC的作用 BFC的作用 和浮动元素产生边界 使 BFC 内部浮动元素不会到处乱跑 解决margin合并的问题这个就好理解多了 和浮动元素产生边界12345678910111213141516&lt;div class="left"&gt;&lt;/div&gt;&lt;div class="right"&gt;&lt;/div&gt;&lt;style&gt;.left&#123; float: left; height: 200px; width: 400px; border: 2px solid blue;&#125;.right&#123; height: 200px; width: 500px; border: 2px solid red; /* display: inline-block; */&#125;&lt;/style&gt; 如图，浮动的蓝色DIV和红色DIV是重叠在一起的，像是浮动的蓝色DIV脱离了文档流一样，那么我们就要触发BFC清除浮动带来的影响 123456.right&#123; height: 200px; width: 500px; border: 2px solid red; display: inline-block; //这里通过将display设置为inline-block的方式来触发BFC&#125; 这样我们就可以通过触发BFC的方式来清除浮动了 使 BFC 内部浮动元素不会到处乱跑 12345678910111213141516&lt;div class="right"&gt; &lt;div class="right-inner"&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt;.right&#123; width: 500px; border: 2px solid red; /* display: inline-block; */ &#125; .right-inner&#123; height: 400px; width: 100px; border: 2px solid black; float: left;&#125;&lt;/style&gt; 当内部元素浮动的时候，因为脱离了文档流而导致父元素高度坍塌，这时候可以通过触发BFC解决这个问题 1234567&lt;style&gt;.right&#123; width: 500px; border: 2px solid red; display: inline-block; //通过inline-block触发BFC &#125; &lt;/style&gt; 如图,问题已经修复了 解决margin合并的问题 12345678910111213141516171819&lt;body&gt; &lt;div id="green" style="background:lightgreen;height:100px;width:100px;"&gt;&lt;/div&gt; &lt;div id="blue" style="background:lightblue;height:100px;width:100px;"&gt;&lt;/div&gt; &lt;div id="red" style="background:pink;height:100px;width:100px;"&gt;&lt;/div&gt;&lt;/body&gt;&lt;style type="text/css"&gt; #green &#123; margin: 10px 10px 10px 10px &#125; #blue &#123; margin: 10px 10px 10px 10px &#125; #red &#123; margin: 10px 10px 10px 10px &#125; body &#123; writing-mode: vertical-lr; &#125; &lt;/style&gt; 解决办法 如何创建BFC 下列方式会创建块格式化上下文： 根元素() 浮动元素（元素的 float 不是 none） 绝对定位元素（元素的 position 为 absolute 或 fixed） 行内块元素（元素的 display 为 inline-block） 表格单元格（元素的 display为 table-cell，HTML表格单元格默认为该值） 表格标题（元素的 display 为 table-caption，HTML表格标题默认为该值） 匿名表格单元格元素（元素的 display为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是HTML table、row、tbody、thead、tfoot的默认属性）或 inline-table） overflow 值不为 visible 的块元素 display 值为 flow-root 的元素 contain 值为 layout、content或 paint 的元素 弹性元素（display为 flex 或 inline-flex元素的直接子元素） 网格元素（display为 grid 或 inline-grid 元素的直接子元素） 多列容器（元素的 column-count 或 column-width 不为 auto，包括 column-count 为 1）column-span 为 all 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（标准变更，Chrome bug）。 以上是MDN给出的可以触发BFC的方式 总结我在看其他文章的时候发现了这个 BFC的原理（渲染规则）（1）BFC垂直方向边距重叠问题（2）BFC的区域不会与浮动元素的box重叠（3）BFC是一个独立的容器，外面的元素不会影响里面的元素（4）计算BFC高度的时候浮动元素也会参与计算 这就很好的说明了为什么在清除浮动和margin合并的时候创建BFC区域就可以解决问题了]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>bfc</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kmp算法]]></title>
    <url>%2F2019%2F07%2F11%2Fkmp%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[最近在刷算法题的时候遇到了一题要我们实现indexof这个函数，我在做的时候用的是很暴力的算法，应该是叫BF算法，但是我想到之前上数据结构课的时候老师说过一种算法是不用逐个逐个匹配的，可以根据一定的规律跳着匹配，后来我在评论中看到这种算法叫KMP算法。 KMP算法kmp算法就是在匹配子串中找到相同的前缀和后缀，例如a b c d a b d在字符d的前面的子串中，前面有一个ab，后面也有一个ab，那么当主串与子串匹配到d的时候，如果不匹配，BF算法是从主串的下一个字符重新开始匹配子串，但是KMP算法是这样的，因为d前面的字符串都是匹配的，而子串中又有相同的前缀和后缀，那么就可以说明，与后缀匹配的主串与前缀也是匹配的，所以当下一次匹配的时候，我们可以从前缀的后一个字符开始匹配如下图所以在一开始的时候，我们要对子串构建一个临时数组，这个数组存放的是从这一位字符开始，最长的相同的前缀后缀的长度，就拿上面的abcdabd来举例子 a b c d a b d0 0 0 0 1 2 0 然后，当每次匹配失败的时候，就查找匹配失败字符的前一位字符对应的数组上的数字，也就是找到当前匹配失败的字符前面的字符串的最长匹配的前缀和后缀，下一次主串与子串匹配的时候，根据上面找到的这个数字，从子串中对应的索引来进行匹配，例如主串：A B C D A B X A B C D A B D子串：A B C D A B D当匹配到x的时候，子串对应的D不匹配，这时候查找D前面字符的数字，是2，也就是前缀ab和后缀ab，他们的长度就是2，所以，下一次查找的时候，从数组索引为2的字符开始匹配，也就是c，下一次匹配主串 A B C D A B X A B C D A B D子串 A B C D A B DX与C不匹配，查找C前一位对应的数字，是0，说明没有匹配的前缀后缀那么下一次就从子串的头开始匹配主串A B C D A B X A B C D A B D子串 A B C D A B D匹配成功！ 我讲的可能有一些难懂，具体可以上B站：av3246487,这个人讲的比较具体，每一个步骤都详细讲了 达成成就：B站学习 附上我学习了KMP之后解题的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * @param &#123;string&#125; haystack * @param &#123;string&#125; needle * @return &#123;number&#125; */var strStr = function(haystack, needle) &#123; if(needle === "")return 0; var index = 0; var tempArray = [0]; //求临时数组 for(var index2 = 1; index2 &lt; needle.length;)&#123; if(needle[index] === needle[index2])&#123; tempArray[index2] = index + 1; index2++; index++; &#125;else&#123; if(index != 0)&#123; index = tempArray[index - 1]; &#125;else&#123; tempArray[index2] = 0; index2++; &#125; &#125; &#125; //利用KMP算法解 var i = 0; var j = 0; while(i &lt; haystack.length &amp;&amp; j &lt; needle.length)&#123; if(haystack[i] === needle[j])&#123; i++; j++; &#125;else&#123; if(j != 0)&#123; j = tempArray[j - 1]; &#125;else&#123; i++; &#125; &#125; &#125; if(j === needle.length)&#123; return i-j; &#125; return -1;&#125;;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>KMP</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue指令]]></title>
    <url>%2F2019%2F07%2F01%2FVue%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[v-html可以输出HTML而不是纯文本 v-pre有这个属性的标签里面的内容是不会替换的，例如 1&lt;span v-pre&gt;&#123;&#123;这里面的内容是不会被替换的&#125;&#125;&lt;span&gt; v-if123456789&lt;span v-if="show"&gt;&lt;/span&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; show: true &#125; &#125;)&lt;/script&gt; 对应的还有v-else-if和v-else指令，要注意的是，这两个指令要像编程的时候一样紧跟v-if。 VUE在重新渲染的时候，会尽可能的复用已有的元素，而非重新渲染，如果不希望VUE复用元素的话，可以给元素添加key属性，key的值必须是要唯一的。 v-showv-show与v-if是差不多的，但是v-if是重新渲染，v-show是改变元素的display属性，当v-show为false的时候，display会变成none，要注意的是，v-show不可以在template上使用 v-bind这个指令主要是拿来更新属性的，例如123456789&lt;a v-bind:href="url"&gt;&lt;/a&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; url: "http://www.baidu.com" &#125; &#125;)&lt;/script&gt; 这个指令可以用“:”来简写，也就是上面的代码可以这样写 1&lt;a :href="url"&gt;&lt;/a&gt; 当v-bind需要绑定多个class的时候，我们可以这样写 1234567891011121314&lt;div id='app'&gt; &lt;div :class="&#123;'active': isActive, 'error': isError&#125;"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; isActive: true, error: false &#125; &#125;)&lt;/script&gt;//div就会变成这样&lt;div class="active"&gt; 当然，我们也可以通过methods或者计算属性来返回,也可以在data里面设置一个对象,然后对象里面有对应的属性 1234567891011121314151617181920&lt;div id='app'&gt; &lt;div :class="classes"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; isActive: true, error: false &#125;, computed: &#123; classes: function()&#123; return&#123; active: this.isActivity, error: this.false &#125; &#125; &#125; &#125;)&lt;/script&gt; 数组语法我们可以给绑定的属性一个数组 1&lt;div :class="[activeCls, errorCls]"&gt; 数组里面的元素可以用三元表达式，也可以是一个对象，当然也可以用data，computed，methods在动态设置类名的时候，通常都是使用计算属性来设置的。 在组件中使用v-bind当在自定义组件中使用绑定命令的时候，样式只会在这个组件的根元素上被应用，如果需要在子元素上绑定属性，应该使用组件的props来传递。 v-on这个指令主要是用来绑定事件的，在处理函数内部的this指向的是vue实例，例如1234567891011121314151617&lt;div id="app"&gt; &lt;span v-if="show"&gt;你好你好你好&lt;/span&gt; &lt;button v-on:click="click"&gt;隐藏&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; show: true &#125;, methods: &#123; click: function()&#123; this.show = false; &#125; &#125; &#125;) &lt;/script&gt; 这个指令可以用“@”来简写，也就是 1&lt;button @click="click"&gt;隐藏&lt;/button&gt; ＠click 调用的方法名后 可以不跟括号“（）” 。此时，如果该方法有参数，默认会将原生事件对象 event 传入 如果需要传入event对象的话，VUE提供了一个特殊变量$event，可以将其传入。event后面可以跟一些修饰符 修饰符 作用 .stop 阻止单击事件冒泡 .prevent 提交事件不再重载页面 .capture 事件捕获模式 .self 只有事件在该元素本身触发时回调 .once 只触发一次 修饰符可以串联调用 在监听键盘事件的时候，可以使用按键修饰符 12&lt;!-- 只有在keycode是13的时候才调用vm.submit() --&gt;&lt;input @keyup.13="submit"&gt; 还可以之际配置具体按键Vue.config.keyCodes.f1 = 112; 按键修饰符也可以连用 v-cloak这个指令会在VUE实例结束编译的时候从绑定的HTML元素上移除，这是用来清除“抖动”的，什么是“抖动”呢，在我们使用{{ }}的时候，如果网速较慢，在vue.js文件还未加载出来的时候，这个HTML结构是不会被替换掉的，那么，我们就需要为使用了{{ }}的元素加上一个v-cloak属性，然后设置CSS 123[v-cloak]&#123; display: none;&#125; v-once这个指令代表其元素或着组件只会渲染一次，无论其依赖的数据有没有改变。但是在实际中很少用到，一般用于优化性能 v-for当需要遍历一个对象显示的时候，会用到这个指令，这个指令要结合in来使用 1234567891011121314151617&lt;div id="app"&gt; &lt;ul&gt; &lt;li v-for="book in books"&gt; &#123;&#123; book.name &#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; .... data:&#123; books: [ &#123; name: '123'&#125;, &#123; name: '456'&#125;, &#123; name: '789'&#125; ] &#125; .... v-for还支持一个可选参数作为当前项的索引 1&lt;li v-for="(book, index) in books"&gt; &#123;&#123;index&#125;&#125; - &#123;&#123;book.name &#125;)&lt;/li&gt; 在遍历对象的时候还有参数就会变成这样 1v-for="(value, key, index) in user" v-for也还可以以computed计算的返回值为遍历对象 v-for可以用在template中 数组更新当修改数组的时候，VUE也是会重新渲染视图的，但是当使用filter，concat，slice这些不会改变原数组的方法的时候，是不会重新渲染的。当通过索引直接改变数组项或者通过修改数组长度的时候，VUE是不会重新渲染的。 解决通过索引修改数组而不会重新渲染的问题可以使用VUE内置的SET方法 12Vue.set(app.books, 3, &#123; name: '《css揭秘》' ,author: '[希] Lea Verou ’&#125;); 另外一种方法是通过splice来解决 1234567app.books.splice(3, 1, &#123; name: '123', author: '456'&#125;)//第二个问题也是用splice来解决app.books.splice(1)//第二个参数不写就是删除掉后面全部的 v-modelv-model用于在表单元素上双向绑定数据 单选按钮在只有一个单选按钮的时候，可以直接使用v-bind来绑定checked属性 1234567&lt;input type="radio" :checked="picked"&gt;....data: &#123; picked: true&#125;.... 当有多个单选框并且互斥的时候，要配合v-model和value来使用，将v-model绑定到一个变量中，然后这个变量存的是不同单选框的value，当这个变量与单选框的value相同的时候，这单选按钮就被选中了。 复选框当只有一个复选框的时候，直接使用v-model来绑定一个布尔变量，true选中，false不选中，当有多个复选框的时候，与单选一样，也要v-model配合value来使用。但是变量就变成了一个数组，数组中存放的是每个复选框的value，当复选框被选中的时候，这个复选框的value值会自动push到这个数组中。而这个数组中存在与某个复选框的value的值相同的时候，这个复选框也会被选中。 下拉框在select用v-model绑定一个数组，如果数组中的项与option中的项匹配，那么这个option就会被选中，如果option有value，那么会优先匹配value，如果要开启多选，给v-model加多一个multiple属性 修饰符v-model也是有修饰符的 .lazy在输入框中，默认是在input事件中同步输入框的数据，但是如果给v-model加上.lazy修饰符之后，就是在change事件中同步输入框的数据了，也就是说，只有在input失去焦点或者按下回车的时候，v-model对应的数据才会更新。 .number.number可以将输入的数据类型转换为Number，默认的input数据类型是String .trim.trim修饰符可以过滤掉输入的首尾空格]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue学习基础篇]]></title>
    <url>%2F2019%2F07%2F01%2FVue%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[过滤器vue可以在{{ }}插值的尾部添加一个 “|” 来对数据进行过滤123456789101112131415161718192021222324252627282930313233&#123;&#123; date | formatDate&#125;&#125;&lt;script&gt; var padDate = function(value)&#123; return value &lt; 10 ? '0' + value : value; &#125; var app = new Vue(&#123; el: #app, data: new Date(), filters: &#123; formatDate: function(value)&#123; var date = new Date(value); var year = date.getFullYear(); var month = padDate(date.getMonth() + 1); var day = padDate(date.getDate()); var hours = padDate(date.getHours()); var minutes = padDate(date.getMinutes()); var seconds = padDate(date.getSeconds()); return year + '-' + month + "-" + day + "" + hours + ":" + minutes + ":" + seconds; &#125; &#125;, mounted: function()&#123; this.timer = setInterval(function()&#123; this.date = new Date(); &#125;.bind(this),1000); &#125;, destoryed: function()&#123; if(this.timer)&#123; clearInterval(this.timer); &#125; &#125; &#125;)&lt;/script&gt; 过滤器可以串联，也就是可以这样1&#123;&#123; message | filterA | filterB&#125;&#125; 也可以传参1&#123;&#123; message | filter('arg1','arg2')&#125;&#125; 当然了，过滤器接收到的第一个参数是数据本身，第二第三个参数才是我们传入的参数。 计算属性当遇到复杂的操作的时候，我们有时会需要这样做 123&lt;div&gt; &#123;&#123; text.split(",").reverse().join(",") &#125;&#125;&lt;/div&gt; 这样写会变得难以维护，所以我们可以使用计算属性 1234567891011121314&lt;div id="app"&gt;&#123;&#123; reversedText &#125;&#125;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; text: "123,456" &#125; computed: &#123; reversed: function()&#123; return this.text.split(",").reverse().join(","); &#125; &#125; &#125;)&lt;/script&gt; 在计算属性中包含着getter和setter，getter在获取这个属性的时候会触发，setter在设置这个属性的时候会触发，不过我们一般都使用默认的getter和setter，不必更改。计算属性不仅可以依赖当前VUE实例，还可以依赖另外的VUE实例123456789101112131415161718&lt;div id="app1"&gt;&lt;/div&gt;&lt;div id="app2"&gt;&#123;&#123; resveredText &#125;&#125;&lt;/div&gt;&lt;script&gt; var app1 = new Vue(&#123; el: '#app1', data: &#123; name: "123,456" &#125; &#125;) var app2 = new Vue(&#123; el: '#app2', computed: &#123; resveredText: function()&#123; return app1.name.split(","); &#125; &#125; &#125;)&lt;/script&gt; 计算属性缓存其实上面的computed也可以用一个函数来实现，并且用函数实现还可以传递参数，那用函数和用计算属性有什么区别呢？ 属性 页面重新渲染 适用场景 computed 不变化 较大的计算量和较低的更新频率 methods 页面元素的data变化 无缓存 这里的意思是，当使用computed来实现的时候，只有其依赖的数据本身变化了，视图才会去更新，但是如果用methods来实现的话，只要页面有有一个地方被重新渲染了，调用methods的地方都会更新。 组件组件注册全局注册123Vue.component('my-component',&#123; template: "&lt;div&gt;我的第一个component&lt;/div&gt;"&#125;) 局部注册12345678910var myComponent = &#123; template: "&lt;div&gt;我的第一个component&lt;/div&gt;"&#125;var app = new Vue(&#123; el: "#app", component: &#123; "my-component": myComponent &#125;&#125;) 组件嵌套可以在一个组件里面注册另一个组件例如 1234567891011121314151617var child = &#123; template: "&lt;div&gt;子component&lt;/div&gt;"&#125;var myComponent = &#123; template: "&lt;div&gt;我的第一个component&lt;/div&gt;&lt;child&gt;&lt;/child&gt;" component: &#123; "child": child &#125;&#125;var app = new Vue(&#123; el: "#app", component: &#123; "my-component": myComponent &#125;&#125;) is的使用Vue 组件的模板在某些情况下会受到 HTML 的限制，比如＜table＞内规定只允许是〈tr〉、＜td＞、 ＜th＞等这些表格元素，所以在＜table＞内直接使用组件是无效的。 这种情况下，可以使用特殊的 is 属性来挂载组件 123&lt;table&gt; &lt;tbody is="my-component"&gt;&lt;/tbody&gt;&lt;/table&gt; 传递参数12345678910111213&lt;div id='app'&gt; &lt;my-compontent message="haha"&gt;&lt;/my-compontent&gt;&lt;/div&gt;&lt;script&gt; Vue.compontent('my-compontent',&#123; props: ['message'], template: "&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;" &#125;) var app = new Vue(&#123; el: '#app' &#125;)&lt;/script&gt; 如果要动态传递的话，将message用v-bind绑定就可以了 单向数据流从父组件传过来的数据，父组件的数据变化时会传递给子组件，但是反过来不可以。有两种情况需要改变prop的 这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。在这种情况下，最好定义一个本地的 data 属性并将这个 prop 用作其初始值： 123456props: ['initialCounter'],data: function () &#123; return &#123; counter: this.initialCounter &#125;&#125; 这个 prop 以一种原始的值传入且需要进行转换。在这种情况下，最好使用这个 prop 的值来定义一个计算属性： 123456props: ['size'],computed: &#123; normalizedSize: function () &#123; return this.size.trim().toLowerCase() &#125;&#125; 注意在 JavaScript 中对象和数组是通过引用传入的，所以对于一个数组或对象类型的 prop 来说，在子组件中改变这个对象或数组本身将会影响到父组件的状态。 这句话的意思是如果你传入的props是一个对象或者是数组的话，因为对象和数组的传递是引用类型的，当你在子组件改变这个对象或者数组的时候，父组件中对应的数组或者对象也会被改变。 数据验证1234567891011121314151617181920212223242526272829props: &#123; //数字类型 propA: Number, //字符串类型或者数字类型 propB: [String,Number], //布尔类型 propC: &#123; type: Boolean, default: true &#125;, //数字类型并且必须传 propD: &#123; type: Number, required: true &#125;, //如果要求是对象或者数组，默认值要用函数返回 propE: &#123; type: Object, default: function()&#123; return &#123;&#125;; &#125; &#125; //自定义验证函数 propF: &#123; validator: function(value)&#123; return value &gt; 10; &#125; &#125;&#125; type的类型可以是 String Array Number Object Function Boolean当然也可以自定义类型的判断，用instanceof就可以了。 组件通信子组件可以通过$emit触发一个事件，这个事件是被父组件监听的。 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;div id='app'&gt; &lt;my-component //监听事件 @addCount="handleTotal" @reduceCount="handleTotal"&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;script&gt; Vue.component("my-component",&#123; template: '\ &lt;div&gt;\ &lt;button @click="handleAdd"&gt;+1&lt;/button&gt;\ &lt;button @click="handleReduce"&gt;-1&lt;/button&gt;\ &lt;div&gt;', data: function()&#123; return &#123; counter: 0 &#125; &#125;, mehtods: &#123; handleAdd: function()&#123; this.counter++; //触发事件 this.$emit('addCount',this.counter); &#125;, handleReduce: function()&#123; this.counter--; this.emit('reduceCount',this.counter); &#125; &#125; &#125;); var app = new Vue(&#123; el: '#app', data: &#123; counter: 0 &#125;, methods: &#123; handleTotal: function(total)&#123; this.counter = total &#125; &#125; &#125;)&lt;/script&gt; 除了监听自定义事件，还可以监听原生事件，监听该组件的根元素 1&lt;my-component @click.native="handleClick"&gt;&lt;/my-component&gt; 组件上的V-model当在组件上使用v-model的时候，会默认利用名为value的prop和名为input的事件，也就是说，你可以在组件设置里面接收一个叫value的prop，当emit一个input事件的时候组件也会响应去更新v-model对应的数据。可是如单选框，复选框等类型的输入控件会将value特性用于不同的目的，那么组件就要这样设置 12345678910111213141516Vue.component('base-checkbox', &#123; model: &#123; prop: 'checked', event: 'change' &#125;, props: &#123; checked: Boolean &#125;, template: ` &lt;input type="checkbox" v-bind:checked="checked" v-on:change="$emit('change', $event.target.checked)" &gt; `&#125;) 现在在这个组件上使用 v-model 的时候： 1&lt;base-checkbox v-model="lovingVue"&gt;&lt;/base-checkbox&gt; 这里的 lovingVue 的值将会传入这个名为 checked 的 prop。同时当 触发一个 change 事件并附带一个新的值的时候，这个 lovingVue 的属性将会被更新。 利用v-model双向通信父组件向子组件通信-&gt;利用props传递子组件向父组件通信-&gt;通过触发父组件监听的事件 12345678910111213141516171819202122232425262728293031&lt;div id='app'&gt; &lt;my-component v-model='counter'&gt;&lt;/my-component&gt; &lt;button @click='handleAdd'&gt;+1&lt;/button&gt;&lt;div&gt;&lt;script&gt; Vue.component("my-component",&#123; template: '&lt;input type="text" :value="value" @input="handleCounter"&gt;', props=['value'], methods: &#123; handleCounter: function(event)&#123; this.$emit('input',event.target.value); &#125; &#125;, data: function()&#123; return &#123; counter: 0; &#125; &#125; &#125;) var app = new Vue(&#123; el: '#app', methods: &#123; handleAdd: function()&#123; this.counter++ &#125; &#125;, data: &#123; counter: 0; &#125; &#125;)&lt;/script&gt; 利用空VUE实例实现组件间通信123456789101112131415161718192021222324252627282930var bus = new Vue();//组件1Vue.component("com1",&#123; template: '&lt;button @click='changeValue'&gt;+1&lt;/button&gt;', data: function()&#123; return &#123; val: 0 &#125; &#125;, methods: &#123; changeValue: function()&#123; this.val++; bus.$emit('changeValue',this.val); &#125; &#125;&#125;)//组件2Vue.component("com2",&#123; data: function()&#123; return &#123; val :0 &#125; &#125;, mounted: function()&#123; bus.on('changeValue',function(val)&#123; this.val = val; console.log(this.val); &#125;); &#125;&#125;) 父链可以通过this.$parent访问到父组件，还可以通过this.$children访问其子组件，可以递归向上向下一直访问 子组件索引1234567//为组件添加一个ref属性&lt;my-component ref="comA"&gt;&lt;/my-component&gt;... //可以这样子来访问子组件 this.$refs.comA... slotslot的意思是插槽，在组件的模板中使用slot，那么在调用组件的时候，就可以向这些slot插入元素。 单个slot12345678910111213141516171819&lt;div id='app'&gt; &lt;my-component&gt; &lt;p&gt;分发的内容&lt;/p&gt; &lt;p&gt;分发的内容2&lt;/p&gt; &lt;/my-component&gt;&lt;/div&gt;&lt;script&gt; Vue.component("my-component",&#123; template: '\ &lt;div&gt;\ &lt;slot&gt;\ &lt;div&gt;默认内容&lt;/div&gt; &lt;/slot&gt;\ &lt;/div&gt;' &#125;)var app = new Vue(&#123; el: '#app'&#125;)&lt;/script&gt; 渲染出来的结果是 123456&lt;div id='app'&gt; &lt;div&gt; &lt;p&gt;分发的内容&lt;/p&gt; &lt;p&gt;分发的内容2&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 还可以给slot加上名字，就可以指定slot要插入什么内容 1234567891011121314151617181920212223242526272829&lt;div id='app'&gt; &lt;my-component&gt; &lt;h2 slot='header'&gt;题目&lt;h2&gt; &lt;p&gt;分发的内容&lt;/p&gt; &lt;p&gt;分发的内容2&lt;/p&gt; &lt;div slot='footer'&gt;底部信息&lt;/div&gt; &lt;/my-component&gt;&lt;/div&gt;&lt;script&gt; Vue.component("my-component",&#123; template: '\ &lt;div&gt;\ &lt;div class="header"&gt;\ &lt;slot name="header"&gt;&lt;/slot&gt;\ &lt;/div&gt;\ &lt;div class="main"&gt;\ &lt;slot&gt;\ &lt;div&gt;默认内容&lt;/div&gt;\ &lt;/slot&gt;\ &lt;/div&gt;\ &lt;div class="footer"&gt;\ &lt;slot name="footer"&gt;&lt;/slot&gt;\ &lt;/div&gt;\ &lt;/div&gt;' &#125;)var app = new Vue(&#123; el: '#app'&#125;)&lt;/script&gt; 渲染结果 123456789101112&lt;div id='app'&gt; &lt;div class='header'&gt; &lt;h2&gt;题目&lt;/h2&gt; &lt;/div&gt; &lt;div class='main'&gt; &lt;p&gt;分发的内容&lt;/p&gt; &lt;p&gt;分发的内容2&lt;/p&gt; &lt;/div&gt; &lt;div class='footer'&gt; &lt;div&gt;底部信息&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 在模板中，有一个没有名字的slot，所以父组件没有指定slot的内容才可以放在这里，如果模板中没有匿名slot，那么父组件中这些没有指定slot的内容将会被舍去。 作用域slot就是让父组件决定结构，子组件提供数据1234567891011121314151617··· &lt;my-component&gt; &lt;template scope='props'&gt; &lt;p&gt;父组件的内容&lt;/p&gt; &lt;p&gt;&#123;&#123; props.msg &#125;&#125;&lt;/p&gt; &lt;/template&gt; &lt;/my-component&gt;···... Vue.component("my-component",&#123; template: '\ &lt;slot msg="子组件的内容"&gt; &lt;/slot&gt; ' &#125;)... 1234567891011121314151617181920212223242526272829303132&lt;my-component :books='books'&gt;//绑定父组件books &lt;template slot='book' scope='props'&gt; &lt;li&gt;&#123;&#123; props.bookName &#125;&#125;&lt;li&gt; &lt;/template&gt;&lt;/my-component&gt;Vue.component('my-component',&#123; props: &#123; //获取父组件传进来的books books: &#123; type: Array default: function()&#123; return []; &#125; &#125; template:'\ &lt;ul&gt;\ &lt;!--绑定传进来的bookName,父组件通过props.bookName访问到，也就是--&gt; &lt;!--子组件向父组件提供了数据--&gt; &lt;slot name="book" v-for="book in books" :book-Name="book.name"&gt;\ &lt;/ul&gt;\' &#125;&#125;)var app = new Vue(&#123; el: '#app', data: &#123; books:[ &#123;name: 'javascript'&#125;, &#123;name: 'css'&#125;, &#123;name: 'html'&#125; ] &#125;&#125;) 递归组件可以在组件内部调用自己，设置name属性就可以了 1234567···name: 'my-component'template:'\&lt;div&gt;\ &lt;my-component&gt;&lt;/my-component&gt;\&lt;/div&gt;'··· 要注意设置递归跳出条件，否则内存会溢出 内联模板这个功能就是在组件使用的时候加一个inline-template，然后注册组件的时候就不用设置template了，template以组件内的内容为准。 动态组件有一个特殊的元素可以用于动态挂载不同的组件 123456789101112131415161718192021222324252627&lt;component :is="currentView"&gt;&lt;/component&gt;&lt;button @click='handleChange('A')'&gt;切换到A&lt;/button&gt;&lt;button @click='handleChange('B')'&gt;切换到B&lt;/button&gt;&lt;button @click='handleChange('C')'&gt;切换到C&lt;/button&gt;···var app = new Vue(&#123; components: &#123; comA: &#123; template: '&lt;div&gt;组件A&lt;/div&gt;' &#125;, comB: &#123; template: '&lt;div&gt;组件B&lt;/div&gt;' &#125;, comC: &#123; template: '&lt;div&gt;组件C&lt;/div&gt;' &#125; &#125;, data: &#123; currentView: 'comA' &#125;, methods: &#123; handleChange: function(component)&#123; this.currenntView = 'com' + component; &#125; &#125;&#125;) 也可以创建一个对象然后将组件绑定在这个对象上 123456var Home = &#123; template:'&lt;p&gt;Welcome home!&lt;/p&gt;' &#125; ;var app =new Vue(&#123; el:'#app', data: &#123; currentView: Home &#125;) $nextTickvue的更新是异步更新的，例如，Vue在观察到数据变化要更新DOM的时候，VUE会开启一个队列，并缓冲在同一事件循环中发生的所有数据改变，缓冲的时候会去除掉所有重复的数据。在下一个tick中，vue才回去刷新队列执行实际的DOM操作。 1234567891011··· this.showDiv = true; //下面的句子会报错，因为这个时候DIV还没有被创建出来的 var text = document.getElementById('div').innerHTML··· //利用$nextTick在DOM更新完成的时候执行 this.showDiv = true; this.$nextTick(function()&#123; var text = document.getElementById('div').innerHTML &#125;) X-Templates在script标签里面写模板,在script标签里面使用text/x-template类型就可以了 123456789&lt;script type="text/x-template" id="my-component"&gt; &lt;div&gt;利用script写模板&lt;/div&gt;&lt;/script&gt;&lt;script&gt; Vue.component("my-component",&#123; template: 'my-component' &#125;);&lt;/script&gt; 手动挂载实例如果Vue在实例化的时候没哟收到el选项，此时的VUE实例是处于未挂载的状态的，Vue提供了Vue.extend和$mount两种方法来手动挂载实例。 12345678910111213141516171819202122&lt;div id='app'&gt;&lt;script&gt; var myComponent = Vue.extend(&#123; template: "&lt;div&gt;hello: &#123;&#123; name &#125;&#125;&lt;/div&gt;", data: function()&#123; return &#123; name: 'Aresn' &#125; &#125; &#125;); new myComponent().$mount('#app'); //还可以这样挂载 new myComponent(&#123; el: '#app' &#125;) //或者这样，先渲染再挂载 var component = new myConponent().$mount(); document.getElementById('app').appendChild(component.$el);&lt;/script&gt; 自定义指令我个人理解，指令就是让这个组件干什么，而组件就是说这个元素是什么。组件的注册方式和组件大体是相同的指令有几个钩子函数 bind 当指令第一次绑定到元素的时候触发，多用于绑定事件 inserted 当被绑定元素插入到父节点的时候触发，即使父节点不在document中 update 被绑定元素所在的模板更新的时候触发 componentUpdate 被绑定元素所在模板完成一次更新周期的时候调用 unbind 指令和元素解绑的时候调用 其中每个钩子函数又有几个参数可以使用 el 指令绑定的元素 bingding 一个对象，包含以下属性 name 指令的名字 value 指令的绑定值 oldValue 指令绑定的前一个值，限于update和componentUpdated中使用 expression value的字符串形式 arg 传给指令的参数 modifiers 一个包含修饰符的对象 vnode Vue编译生成的虚拟节点 oldValue 上一个虚拟节点，限于update和componentUpdated中使用]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博文]]></title>
    <url>%2F2019%2F05%2F21%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E6%96%87%2F</url>
    <content type="text"><![CDATA[这是我的博客的第一篇文章，就讲讲我是如何搭建我的博客的吧 环境准备Node首先我们要为我们的电脑装上node，直接去官网下载安装好配置好环境变量就可以了 Hexo接着我们要安装node环境下的hexo框架，这个框架可以很方便的为我们快速生成一个博客的模板，并且还有许多主题可以选择 git我们还要在电脑上安装git，这样我们就可以将我们的博客部署到github上 搭建过程1npm install hexo -g 这里我们全局安装一下hexo框架，然后建立一个项目文件夹，这个文件夹是用来装我们的blog项目的首先要打开CMD，用cd命令跳转到我们建立好的blog文件夹，然后用hexo初始化这个文件夹，比如我的 12cd E://bloghexo init 这样子我们这个文件夹就已经是一个可以运行的博客了 123hexo startINFO Start processingINFO Hexo is running at http://localhost:4000 . Press Ctrl+C to stop. 当看到这个语句的时候，我们的博客就已经运行起来了，只需要在浏览器中输入localhost:4000就可以访问到我们的博客了 主题更换如果我们想要更换主题的话，我们可以做以下的更改 首先要获取到主题之前我们已经安装好了git，我们只需要用git clone这个命令就可以将主题文件获取到本地，例如我的 1git clone https://github.com/theme-next/hexo-theme-next.git themes/next 这里要注意的是，我们要将主题文件clone到项目中的themes文件夹中 修改hexo的配置文件打开项目文件夹下的_config.yml，找到theme这个配置项，将其修改成themes文件夹里面对应的文件夹名称就可以了 部署到github建立仓库首先到github中建立一个仓库，仓库名一定要是username.github.io,uesrname是你的github用户名,否则后面访问会出现404 修改配置文件找到_config.yml,修改里面的#Deployment选项， 1234#Deployment type：git repo: //刚刚建立的github仓库的http地址 branch: master 改好之后就保存就可以了 推送然后我们可以使用hexo三连 123hexo cleanhexo g //生成hexo d //推送到服务器 这个时候你就可以访问username.github.io，uesrname是你的github用户名来看到你的个人博客啦。 最后如果你是一个前端开发人员的话，你也可以到主题文件夹中对你的博客进行魔改，这也是我接下来准备做的工作。]]></content>
      <categories>
        <category>教程</category>
      </categories>
  </entry>
</search>
